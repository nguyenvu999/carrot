<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>For Na y√™u - Final Smooth Version</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Montserrat:wght@300;400;800&display=swap" rel="stylesheet">

    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #050505; 
            font-family: 'Montserrat', sans-serif; user-select: none;
        }
        #background-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
            background: radial-gradient(circle at center, #9c4b75 0%, #5e2240 45%, #1f0814 100%);
        }
        #noise-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
            opacity: 0.04; pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 2; }
        
        #visualizer-canvas {
            position: absolute; 
            bottom: 25px; 
            left: 50%; 
            transform: translateX(-50%);
            width: 40%; 
            height: 60px; 
            z-index: 15; 
            pointer-events: none; 
            opacity: 0.8; 
        }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 50px 0 30px 0;
        }
        h1 { 
            color: #ffffff; font-family: 'Montserrat', sans-serif; font-size: 30px; font-weight: 800; 
            text-transform: uppercase; letter-spacing: 5px; margin: 0; 
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.6); opacity: 0; 
            animation: fadeIn 3s ease-out forwards 1s;
        }
        .hide-title { opacity: 0 !important; }
        .guide-container { margin-bottom: 110px; text-align: center; opacity: 0.8; transition: opacity 0.3s; }
        .guide-text { 
            color: #ffcae5; font-size: 14px; font-weight: 300; font-style: italic; 
            text-shadow: 0 0 5px rgba(255, 105, 180, 0.5);
        }
        .highlight { color: #ffffff; font-weight: 600; text-decoration: underline decoration-pink; }

        /* ƒê√É ·∫®N WEBCAM NH∆ØNG V·∫™N ƒê·ªÇ N√ì HO·∫†T ƒê·ªòNG */
        #webcam-wrapper {
            position: absolute; visibility: hidden; width: 1px; height: 1px; pointer-events: none;
        }
        
        #status-bar {
            position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(82, 37, 56, 0.8);
            padding: 2px 0; color: #ffcae5; font-size: 10px; text-align: center; z-index: 60;
        }
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a0510; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1s ease;
        }
        .loader-text { color: #ff9ecd; font-family: 'Great Vibes', cursive; margin-top: 20px; font-size: 30px; }
        .spinner {
            width: 30px; height: 30px; border: 2px solid rgba(255, 158, 205, 0.2); 
            border-radius: 50%; border-top-color: #ff9ecd; animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>
    <div id="loading-screen"><div class="spinner"></div><div class="loader-text">Loading Love...</div></div>
    <div id="background-layer"></div><div id="noise-overlay"></div><div id="canvas-container"></div>
    <canvas id="visualizer-canvas"></canvas>
    
    <div id="ui-layer">
        <h1 id="main-title">CAROT_PEN</h1>
        <div class="guide-container"><span class="guide-text" id="guide-text">ƒêang chu·∫©n b·ªã...</span></div>
    </div>

    <div id="webcam-wrapper"><video id="webcam" autoplay playsinline muted></video></div>
    <div id="status-bar">H·ªá th·ªëng ƒëang s·∫µn s√†ng...</div>
    
    <audio id="audio-bg" src="./audio.mp3" loop></audio>
    <audio id="audio-letter" src="./audio2.mp3" loop></audio>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        const CONFIG = {
            maxCount: 20000,      
            particleSize: 0.08,   
            spread: 100,
            fadeSpeed: 1.5,       // Ch·∫≠m l·∫°i ƒë·ªÉ m∆∞·ª£t h∆°n
            slideSpeed: 12.0,     // Gi·∫£m t·ªëc ƒë·ªô tr∆∞·ª£t ·∫£nh
            slideGap: 45,     
            smoothFactor: 0.08,   // Gi·∫£m s·ªë n√†y gi√∫p h·∫°t b√°m tay m∆∞·ª£t h∆°n, √≠t b·ªã gi·∫≠t
            gestureThreshold: 15, // TƒÉng ng∆∞·ª°ng nh·∫≠n di·ªán ƒë·ªÉ tr√°nh nh·∫£y tr·∫°ng th√°i li√™n t·ª•c
            heartThreshold: 0.15,
            sparkleCount: 150     
        };

        const IMG_FOX = './target.png'; 
        const IMG_PEN = './target2.png'; 
        const IMG_LETTER = './mess.png'; 
        const IMG_PHOTO_SINGLE = './photo.png';
        const SLIDE_IMAGES = ['./image/image1.jpeg', './image/image2.jpeg', './image/image3.jpeg', './image/image4.jpeg', './image/image5.jpeg', './image/image6.jpeg'];

        let scene, camera, renderer, composer, clock, bloomPass;
        let mainGroup, instancedMesh, messageMesh, singlePhotoMesh, slideshowGroup; 
        let glitterSystem, starSystem, whiteStarSystem, sparkleSystem; 
        let sparkleIndices = []; 
        let auraRingSystem; const AURA_COUNT = 300; 

        let audioContext, audioAnalyser, audioSource, audioDataArray;
        let isAudioSetup = false;
        let visualizerCanvas, visualizerCtx;

        let slides = []; let totalSlideWidth = 0; 
        let pCurrent, pTarget, pScatter; let count = 0;
        let dummy = new THREE.Object3D();
        const _tempColor = new THREE.Color(); const _targetColor = new THREE.Color(0xff69b4);

        let handLandmarker, video; let isFoxLoaded = false, isPenLoaded = false;
        let appState = 'FOX'; let interactionLock = 0; let lastActionTime = 0; 
        let isLoadingDelay = false; let loadingDelayTime = 0;

        let handParallax = { x: 0, y: 0 }; let smoothedParallax = { x: 0, y: 0 }; 
        let imagesData = { 1: { data: null, width: 0, height: 0 }, 2: { data: null, width: 0, height: 0 } };

        let currentBloomStrength = 0; let currentOpacity = 1.0;
        let animLetter = { scale: 0, y: -50, pScale: 1, pY: 0 };
        let animSlide = { opacity: 0 }; let animSinglePhoto = { opacity: 0, scale: 0 };
        let gestureBuffer = { pinch: 0, open: 0, heart: 0, fist: 0 };

        async function init() {
            updateStatus("ƒêang kh·ªüi t·∫°o Engine...");
            initThree();
            setupPostProcessing();
            setupMessageMesh(); setupSinglePhoto(); setupSlideshow(); 
            initInstancedMesh(CONFIG.maxCount); 
            setupSparkles(); 
            setupGlitter(); setupFloatingStars(); setupWhiteStars();
            setupAuraRing();
            
            const p1 = loadImage(IMG_FOX, 1); 
            const p2 = loadImage(IMG_PEN, 2);
            
            Promise.all([p1, p2])
                .then(() => { 
                    useImageData(1); 
                    updateStatus("ƒêang kh·ªüi ƒë·ªông AI Vision..."); 
                })
                .catch(err => { 
                    console.error("L·ªói t·∫£i t√†i nguy√™n", err); 
                    updateStatus("L·ªói t·∫£i file h√¨nh ·∫£nh"); 
                });

            await initMediaPipe();
            setupEvents();
            initVisualizer2D();
            animate();
        }

        function hideLoading() {
            const el = document.getElementById('loading-screen');
            if(el) { el.style.opacity = 0; setTimeout(() => el.remove(), 1000); }
        }

        function setupAudioSystem() {
            if (isAudioSetup) return;
            const audioElement = document.getElementById('audio-bg');
            if (!audioElement) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            audioSource = audioContext.createMediaElementSource(audioElement);
            audioAnalyser = audioContext.createAnalyser();
            audioAnalyser.fftSize = 256; 
            audioSource.connect(audioAnalyser); audioAnalyser.connect(audioContext.destination);
            audioDataArray = new Uint8Array(audioAnalyser.frequencyBinCount);
            isAudioSetup = true;
        }

        function initVisualizer2D() {
            visualizerCanvas = document.getElementById('visualizer-canvas');
            if(visualizerCanvas) {
                visualizerCtx = visualizerCanvas.getContext('2d');
                const updateSize = () => { visualizerCanvas.width = visualizerCanvas.offsetWidth; visualizerCanvas.height = visualizerCanvas.offsetHeight; };
                updateSize(); window.addEventListener('resize', updateSize);
            }
        }

        function drawVisualizer() {
            if (!isAudioSetup || !visualizerCtx) return;
            const width = visualizerCanvas.width; const height = visualizerCanvas.height; const ctx = visualizerCtx;
            ctx.clearRect(0, 0, width, height);
            audioAnalyser.getByteFrequencyData(audioDataArray);
            
            const barWidth = (width / audioDataArray.length) * 2.5; 
            let x = 0; const centerY = height / 2;
            
            for (let i = 0; i < audioDataArray.length; i+=2) { 
                const barHeight = (audioDataArray[i] / 255) * height * 0.6; 
                ctx.fillStyle = `rgba(255, ${150 + i}, 200, 0.8)`;
                ctx.fillRect(width/2 + x, centerY - barHeight/2, barWidth, barHeight);
                ctx.fillRect(width/2 - x - barWidth, centerY - barHeight/2, barWidth, barHeight);
                x += barWidth + 2; 
            }
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x5e2240, 0.002);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 70;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            container.appendChild(renderer.domElement);
            clock = new THREE.Clock();
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth/4, window.innerHeight/4), 1.5, 0.8, 0.8);
            bloomPass.threshold = 0; bloomPass.strength = 0; bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);
        }

        function initInstancedMesh(cnt) {
            const geo = new THREE.IcosahedronGeometry(CONFIG.particleSize, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1, depthWrite: false });
            instancedMesh = new THREE.InstancedMesh(geo, mat, cnt);
            pCurrent = new Float32Array(cnt*3); pTarget = new Float32Array(cnt*3); pScatter = new Float32Array(cnt*3);
            mainGroup = new THREE.Group(); mainGroup.add(instancedMesh); scene.add(mainGroup);
        }

        function setupSparkles() {
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(CONFIG.sparkleCount * 3), 3));
            geom.setAttribute('color', new THREE.BufferAttribute(new Float32Array(CONFIG.sparkleCount * 3), 3));
            const mat = new THREE.PointsMaterial({ size: 0.6, transparent: true, opacity: 1.0, map: createCircleTexture(), vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false });
            sparkleSystem = new THREE.Points(geom, mat); mainGroup.add(sparkleSystem); 
        }

        function setupAuraRing() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(AURA_COUNT * 3);
            for (let i = 0; i < AURA_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2; 
                const r = 45 + (Math.random() - 0.5) * 8;
                positions[i*3] = r * Math.cos(theta); 
                positions[i*3+1] = r * Math.sin(theta) * 0.7; 
                positions[i*3+2] = (Math.random() - 0.5) * 20;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            auraRingSystem = new THREE.Points(geometry, new THREE.PointsMaterial({ color: 0xffaadd, size: 0.8, map: createCircleTexture(), transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false }));
            scene.add(auraRingSystem); 
        }

        function createCircleTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)'); grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            const tex = new THREE.Texture(canvas); tex.needsUpdate = true; return tex;
        }

        function setupSlideshow() {
            slideshowGroup = new THREE.Group(); slideshowGroup.position.z = 25; scene.add(slideshowGroup);
            const textureLoader = new THREE.TextureLoader();
            totalSlideWidth = SLIDE_IMAGES.length * CONFIG.slideGap;
            let startX = -(totalSlideWidth / 2) + (CONFIG.slideGap / 2);
            SLIDE_IMAGES.forEach((path, index) => {
                textureLoader.load(path, (tex) => {
                    const cardMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
                    const cardMesh = new THREE.Mesh(new THREE.PlaneGeometry(24, 28), cardMat);
                    const photoMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0 });
                    const photoMesh = new THREE.Mesh(new THREE.PlaneGeometry(22, 22), photoMat);
                    photoMesh.position.z = 0.1; photoMesh.position.y = 1.5; 
                    const polaroid = new THREE.Group(); polaroid.add(cardMesh); polaroid.add(photoMesh);
                    polaroid.position.set(startX + (index * CONFIG.slideGap), 0, 0);
                    polaroid.userData = { materials: [cardMat, photoMat] };
                    slides.push(polaroid); slideshowGroup.add(polaroid);
                });
            });
        }

        function setupFloatingStars(){
            const geom = new THREE.BufferGeometry(); const pos=new Float32Array(300); const spd=new Float32Array(100);
            for(let i=0;i<100;i++){ pos[i*3]=(Math.random()-0.5)*300; pos[i*3+1]=(Math.random()-0.5)*200; pos[i*3+2]=(Math.random()-0.5)*100-50; spd[i]=0.2+Math.random()*0.5; }
            geom.setAttribute('position',new THREE.BufferAttribute(pos,3)); geom.setAttribute('speed',new THREE.BufferAttribute(spd,1));
            starSystem=new THREE.Points(geom,new THREE.PointsMaterial({color:0xffccdd,size:1.0,transparent:true,opacity:0.6,map:createCircleTexture(), depthWrite:false})); scene.add(starSystem);
        }

        function setupWhiteStars(){
            const geom=new THREE.BufferGeometry(); const pos=new Float32Array(450); const spd=new Float32Array(150);
            for(let i=0;i<150;i++){ pos[i*3]=(Math.random()-0.5)*350; pos[i*3+1]=(Math.random()-0.5)*250; pos[i*3+2]=(Math.random()-0.5)*150-20; spd[i]=0.1+Math.random()*0.3; }
            geom.setAttribute('position',new THREE.BufferAttribute(pos,3)); geom.setAttribute('speed',new THREE.BufferAttribute(spd,1));
            whiteStarSystem=new THREE.Points(geom,new THREE.PointsMaterial({color:0xffffff,size:0.5,transparent:true,opacity:0.5,map:createCircleTexture(), depthWrite:false})); scene.add(whiteStarSystem);
        }

        function setupGlitter(){
            const g=new THREE.BufferGeometry(); const p=new Float32Array(450); const s=new Float32Array(150);
            for(let i=0;i<150;i++){ p[i*3]=(Math.random()-0.5)*200; p[i*3+1]=(Math.random()-0.5)*100; p[i*3+2]=(Math.random()-0.5)*50+20; s[i]=0.5+Math.random()*1.5; }
            g.setAttribute('position',new THREE.BufferAttribute(p,3)); g.setAttribute('speed',new THREE.BufferAttribute(s,1));
            glitterSystem=new THREE.Points(g,new THREE.PointsMaterial({color:0xffb7c5,size:1.5,transparent:true,opacity:0.8,map:createCircleTexture(), depthWrite:false})); scene.add(glitterSystem);
        }

        function setupMessageMesh() {
            new THREE.TextureLoader().load(IMG_LETTER, (tex) => {
                const aspect = tex.image.width / tex.image.height; const h = 40; const w = h * aspect;
                messageMesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 1, side: THREE.DoubleSide, depthWrite: false }));
                messageMesh.position.set(0, -60, 25); messageMesh.scale.set(0,0,0); scene.add(messageMesh);
            });
        }

        function setupSinglePhoto() {
             new THREE.TextureLoader().load(IMG_PHOTO_SINGLE, (tex) => {
                const aspect = tex.image.width / tex.image.height; const h = 40; const w = h * aspect;
                singlePhotoMesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0, side: THREE.DoubleSide }));
                singlePhotoMesh.position.set(0, 0, 30); scene.add(singlePhotoMesh);
             });
        }

        function loadImage(url, id) {
            return new Promise((resolve) => {
                const img = new Image(); img.crossOrigin = "Anonymous"; img.src = url;
                img.onload = () => {
                    const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    const maxSize = 400; const aspect = img.width / img.height; const h = maxSize; const w = Math.floor(h * aspect);
                    canvas.width = w; canvas.height = h; ctx.drawImage(img, 0, 0, w, h);
                    imagesData[id].data = ctx.getImageData(0, 0, w, h).data; imagesData[id].width = w; imagesData[id].height = h;
                    if(id===1) isFoxLoaded=true; else isPenLoaded=true; resolve();
                };
            });
        }

        function useImageData(id) {
            const data = imagesData[id].data; const w = imagesData[id].width; const h = imagesData[id].height; if(!data) return;
            const validIndices = []; for (let i = 0; i < data.length; i += 4) { if (data[i+3] > 50) validIndices.push(i); }
            count = Math.min(CONFIG.maxCount, validIndices.length); instancedMesh.count = count;
            const spread = 60; const imgAspect = h / w; const step = validIndices.length / count;
            sparkleIndices = []; for(let k=0; k<Math.min(CONFIG.sparkleCount, count); k++) sparkleIndices.push(Math.floor(Math.random() * count));
            
            for (let i = 0; i < count; i++) {
                const idx = validIndices[Math.floor(i * step)];
                const px = (idx/4) % w; const py = Math.floor((idx/4) / w);
                pTarget[i*3] = (px / w - 0.5) * spread; pTarget[i*3+1] = -(py / h - 0.5) * spread * imgAspect; pTarget[i*3+2] = (Math.random() - 0.5) * 2;
                const ang = Math.random()*Math.PI*2; const rad = spread * (1.5 + Math.random());
                pScatter[i*3] = Math.cos(ang)*rad; pScatter[i*3+1] = Math.sin(ang)*rad; pScatter[i*3+2] = (Math.random()-0.5)*100;
                _tempColor.setRGB(data[idx]/255, data[idx+1]/255, data[idx+2]/255).lerp(_targetColor, 0.1); instancedMesh.setColorAt(i, _tempColor);
            }
            instancedMesh.instanceMatrix.needsUpdate = true; instancedMesh.instanceColor.needsUpdate = true;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            let musicBass = 0;
            if (isAudioSetup && audioAnalyser) {
                drawVisualizer();
                audioAnalyser.getByteFrequencyData(audioDataArray);
                let sum = 0; for (let i = 0; i < 15; i++) sum += audioDataArray[i];
                musicBass = (sum / 15) / 255; 
            }
            updateParticles(dt, musicBass); 
            updateGlitter(dt); updateFloatingStars(dt); 
            if(auraRingSystem) {
                auraRingSystem.rotation.z += dt * 0.1;
                auraRingSystem.scale.setScalar(1.0 + musicBass * 0.5);
                auraRingSystem.material.opacity = 0.3 + musicBass;
            }
            composer.render();
        }

        function updateParticles(dt, musicBass = 0) {
            if (!instancedMesh) return;
            const time = clock.getElapsedTime();
            let targetOpacity = 1.0, targetBloom = 0.0, moveTarget = 'TARGET'; 
            smoothedParallax.x += (handParallax.x - smoothedParallax.x) * 3.0 * dt; 
            smoothedParallax.y += (handParallax.y - smoothedParallax.y) * 3.0 * dt;

            if (isLoadingDelay) { loadingDelayTime -= dt; if (loadingDelayTime <= 0) isLoadingDelay = false; }

            switch (appState) {
                case 'FOX': targetOpacity = 1.0; setGuide("N·∫Øm tay <span class='highlight'>‚úä</span> ƒë·ªÉ bi·∫øn C√† r·ªët, ho·∫∑c gh√©p Tim ü´∂"); break;
                case 'TRANSITION_TO_PEN': targetOpacity = 0.0; targetBloom = 4.0; moveTarget = 'SCATTER'; if (currentOpacity < 0.05) { useImageData(2); appState = 'REASSEMBLING_PEN'; } break;
                case 'REASSEMBLING_PEN': targetOpacity = 1.0; if (currentOpacity > 0.95) appState = 'PEN'; break;
                case 'PEN': targetOpacity = 1.0; setGuide("Ch·ª•m tay <span class='highlight'>ü§å</span> m·ªü th∆∞, ho·∫∑c X√≤e tay v·ªÅ C√°o"); break;
                case 'READING_LETTER': targetOpacity = 0.4; setGuide("X√≤e tay <span class='highlight'>‚úã</span> ƒë·ªÉ ƒë√≥ng th∆∞"); break;
                case 'BACK_TO_FOX': targetOpacity = 0.0; targetBloom = 4.0; moveTarget = 'SCATTER'; if (currentOpacity < 0.05) { useImageData(1); appState = 'REASSEMBLING_FOX'; } break;
                case 'REASSEMBLING_FOX': targetOpacity = 1.0; if (currentOpacity > 0.95) { appState = 'FOX'; interactionLock = Date.now() + 1500; } break;
                case 'SLIDESHOW': targetOpacity = 0.0; moveTarget = 'SCATTER'; break;
            }

            // X·ª≠ l√Ω hi·ªáu ·ª©ng Letter & Slideshow
            if (appState === 'READING_LETTER') { animLetter.pScale += (0.1 - animLetter.pScale) * 2.0 * dt; animLetter.scale += (1.0 - animLetter.scale) * 3.0 * dt; animLetter.y += (0 - animLetter.y) * 3.0 * dt; } 
            else { animLetter.pScale += (1.0 - animLetter.pScale) * 2.0 * dt; animLetter.scale += (0 - animLetter.scale) * 4.0 * dt; animLetter.y += (-60 - animLetter.y) * 2.0 * dt; }
            if(messageMesh) { messageMesh.scale.setScalar(animLetter.scale); messageMesh.position.y = animLetter.y; }

            if (appState === 'SLIDESHOW') {
                animSlide.opacity += (1.0 - animSlide.opacity) * 3.0 * dt;
                slides.forEach((group) => {
                    group.position.x += CONFIG.slideSpeed * dt; 
                    if (group.position.x > (totalSlideWidth/2)) group.position.x -= totalSlideWidth;
                    group.userData.materials.forEach(m => m.opacity = animSlide.opacity);
                });
            } else {
                animSlide.opacity += (0 - animSlide.opacity) * 3.0 * dt;
                slides.forEach(group => group.userData.materials.forEach(m => m.opacity = animSlide.opacity));
            }

            mainGroup.scale.setScalar(animLetter.pScale);
            mainGroup.rotation.x = smoothedParallax.y * 0.3; mainGroup.rotation.y = smoothedParallax.x * 0.3 + Math.sin(time*0.5)*0.1;

            currentBloomStrength += (targetBloom + musicBass - currentBloomStrength) * 5.0 * dt; 
            bloomPass.strength = currentBloomStrength;

            if (['TRANSITION_TO_PEN', 'BACK_TO_FOX', 'SLIDESHOW'].includes(appState)) currentOpacity -= CONFIG.fadeSpeed * dt; 
            else currentOpacity += CONFIG.fadeSpeed * dt;
            currentOpacity = Math.max(0, Math.min(1, currentOpacity)); instancedMesh.material.opacity = currentOpacity;

            const factor = (moveTarget === 'SCATTER' ? 1.0 : 2.5) * dt;
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                let tx = (moveTarget === 'SCATTER' ? pScatter[i3] : pTarget[i3]);
                let ty = (moveTarget === 'SCATTER' ? pScatter[i3+1] : pTarget[i3+1]);
                let tz = (moveTarget === 'SCATTER' ? pScatter[i3+2] : pTarget[i3+2]);
                pCurrent[i3] += (tx - pCurrent[i3]) * factor;
                pCurrent[i3+1] += (ty - pCurrent[i3+1]) * factor;
                pCurrent[i3+2] += (tz - pCurrent[i3+2]) * factor;
                dummy.position.set(pCurrent[i3], pCurrent[i3+1], pCurrent[i3+2]);
                dummy.scale.setScalar(1.0 + musicBass * 0.2);
                dummy.updateMatrix(); instancedMesh.setMatrixAt(i, dummy.matrix);
            }
            instancedMesh.instanceMatrix.needsUpdate = true;
        }

        async function initMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, { baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_handmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" }, runningMode: "VIDEO", numHands: 2 });
            video = document.getElementById("webcam");
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => { video.srcObject = stream; video.addEventListener("loadeddata", predictWebcam); });
        }

        async function predictWebcam() {
            if (video.readyState >= 2) {
                const result = handLandmarker.detectForVideo(video, performance.now());
                if (result.landmarks && result.landmarks.length > 0) {
                    hideLoading();
                    let centerX = 0, centerY = 0; result.landmarks.forEach(lm => { centerX += lm[0].x; centerY += lm[0].y; }); centerX /= result.landmarks.length; centerY /= result.landmarks.length;
                    handParallax.x = (0.5 - centerX) * 2.5; handParallax.y = (0.5 - centerY) * 2.5;
                    
                    const lm = result.landmarks[0];
                    const dIndex = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    const dPinky = Math.hypot(lm[20].x - lm[0].x, lm[20].y - lm[0].y);
                    const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                    
                    const isFist = (dIndex < 0.2); const isOpen = (dIndex > 0.4); const isPinch = (pinch < 0.05 && !isFist);
                    let isHeart = false; if(result.landmarks.length === 2) { if(Math.hypot(result.landmarks[0][4].x - result.landmarks[1][4].x) < 0.1) isHeart = true; }

                    if(isFist) gestureBuffer.fist++; else gestureBuffer.fist = 0;
                    if(isOpen) gestureBuffer.open++; else gestureBuffer.open = 0;
                    if(isPinch) gestureBuffer.pinch++; else gestureBuffer.pinch = 0;
                    if(isHeart) gestureBuffer.heart++; else gestureBuffer.heart = 0;

                    if (Date.now() > interactionLock) {
                        if (appState === 'FOX') { if (gestureBuffer.heart > CONFIG.gestureThreshold) changeState('SLIDESHOW'); else if (gestureBuffer.fist > CONFIG.gestureThreshold) changeState('TRANSITION_TO_PEN'); }
                        else if (appState === 'PEN') { if (gestureBuffer.pinch > CONFIG.gestureThreshold) changeState('READING_LETTER'); else if (gestureBuffer.open > CONFIG.gestureThreshold) changeState('BACK_TO_FOX'); }
                        else if (['READING_LETTER', 'SLIDESHOW'].includes(appState)) { if (gestureBuffer.open > CONFIG.gestureThreshold) changeState('BACK_TO_FOX'); }
                    }
                }
            } requestAnimationFrame(predictWebcam);
        }

        function changeState(newState) {
            if (Date.now() - lastActionTime < 1000) return; lastActionTime = Date.now();
            document.querySelectorAll('audio').forEach(a => { a.pause(); a.currentTime = 0; });
            if (newState === 'TRANSITION_TO_PEN' || newState === 'FOX' || newState === 'PEN') { 
                setupAudioSystem(); if(audioContext) audioContext.resume();
                document.getElementById('audio-bg').play().catch(() => {});
            }
            if (newState === 'READING_LETTER') document.getElementById('audio-letter').play().catch(() => {});
            appState = newState; updateStatus("Tr·∫°ng th√°i: " + newState);
        }

        function updateStatus(msg) { const el = document.getElementById('status-bar'); if(el) el.innerText = msg; }
        function setupEvents() { window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }); }

        function updateGlitter(dt){
            if(!glitterSystem) return; const p=glitterSystem.geometry.attributes.position.array; const s=glitterSystem.geometry.attributes.speed.array;
            for(let i=0;i<150;i++){ p[i*3+1]+=s[i]*dt*5; if(p[i*3+1]>60) p[i*3+1]=-60; }
            glitterSystem.geometry.attributes.position.needsUpdate=true;
        }
        function updateFloatingStars(dt){
            if(!starSystem) return; const p=starSystem.geometry.attributes.position.array;
            for(let i=0;i<100;i++){ p[i*3+1]+=dt*2; if(p[i*3+1]>100) p[i*3+1]=-100; }
            starSystem.geometry.attributes.position.needsUpdate=true;
        }

        init();
    </script>
</body>
</html>
